
module.exports=xml2rec;

var
  expat=require('node-expat'),
  fs=require('fs')
;

/**
   default options
   options.outputAttributes=false;
   options.trimWhiteSpaceTextNodes=false;
   options.trimLeadingSpaces=false;
   options.trimLeadingSpaces=false;
   options.escapeNewLinesInText=true;
   options.format='csv'; // csv|json
   options.heading=false;
*/
function xml2rec(filename, recordElements, options, cb)
{
  var n=0;

  if(recordElements.constructor!==Array)
    recordElements=[recordElements];

  if(typeof(options)!='object')
  {
    cb=options;
    options={};
  }

  if(typeof(cb)=='string')
  {
    var output=cb;
    if(!options.format)
    {
      if(output.match(/.json$/))
        options.format='json';
      else if(output.match(/.csv$/))
      {
        options.format='csv';
        if(!options.heading)
          options.heading=true;
      }
      else if(output.match(/.tsv$/))
      {
        options.format='tsv';
        if(!options.heading)
          options.heading=true;
      }
    }
    var writer=genWriter(output, options);
    cb=writer.write;
  }

  if(!options.seperator)
  {
    if(options.format=='csv')
      options.seperator=',';
    else if(options.format=='tsv')
      options.seperator='\t';
    else
      options.seperator='|';
  }
  if(typeof(options.trimWhiteSpaceTextNodes)=='undefined')
    options.trimWhiteSpaceTextNodes=true;
  if(typeof(options.escapeNewLinesInText)=='undefined' && options.format=='csv')
    options.escapeNewLinesInText=true;

  var parser = new expat.Parser('UTF-8');
  var json={};
  var ancestorNameStack=[];
  var textStack=[];
  var fqenAttrMap={}; // fqen=Fully Qualified (with respect to ancestors using notation a.b.c) element name
  var fqenOrder=[];

  parser.on('startElement', function(name, attrs) {
    if(-1!=recordElements.indexOf(name))
    {
      json={};
      ancestorNameStack=[];
      textStack=[];
      fqenOrder=[];
      fqenAttrMap={};
    }
    else
    {
      ancestorNameStack.push(name);
      var fqElementName=ancestorNameStack.join(".");
      fqenOrder.push(fqElementName);
      if(options.outputAttributes)
      {
        for(var aName in attrs)
          fqenOrder.push(fqElementName+'#'+aName);
      }
      textStack.push('');
      fqenAttrMap[fqElementName]=attrs;
    }
  });

  parser.on('endElement', function(name) {
    if(-1!=recordElements.indexOf(name))
    {
      if(options.format=='json')
      {
        cb(null, json);
      }
      else {
        var values=[];
        fqenOrder.forEach(function(name) {
          values.push(json[name]);
        });
        if(n==0 && options.heading)
        {
          cb(null, fqenOrder.join(options.seperator));
        }
        ++n;
        cb(null, values.join(options.seperator));
      }
    }
    else {
      const text=textStack.pop();
      var fqen=ancestorNameStack.join('.');
      if(text)
      {
        var newText=text;
        if(options.trimWhiteSpaceTextNodes)
          newText=newText.replace(/^[\r\n\t ]+$/, '');
        if(options.trimLeadingSpaces)
          newText=newText.replace(/^[\r\n\t ]+/, '');
        if(options.trimTrailingSpaces)
          newText=newText.replace(/[\r\n\t ]+$/, '');
        if(options.escapeNewLinesInText)
          newText=newText.replace(/[\n]/g, '\\n');
        json[fqen]=newText;
      }
      if(options.outputAttributes)
      {
        var attrs=fqenAttrMap[fqen];
        if(attrs)
        {
          var keys=Object.keys(attrs);
          if(keys.length>0)
          {
            var attrNames=keys.sort();
            for(var i=0; i<attrNames.length; ++i)
              json[fqen+'#'+attrNames[i]]=attrs[attrNames[i]];
          }
        }
      }
      ancestorNameStack.pop();
    }
  });

  parser.on('text', function(text) {
    textStack[textStack.length-1]+=text;
  });

  parser.on('error', function(error) {
    cb(error);
  });

  parser.on('end', function() {
    if(writer)
      writer.close();
  });

  fs.createReadStream(filename).pipe(parser);
}

function genWriter(filename, options)
{
  var ws=fs.createWriteStream(filename);
  var n=0;

  return {
    write: function(err, rec) {
      if(err)
      {
        console.log(err.toString());
        return;
      }
      if(options.format=='json')
      {
        if(n!=0)
          ws.write(',\n');
        ws.write(JSON.stringify(rec));
      }
      else
      {
        ws.write(rec);
        ws.write('\n');
      }
      ++n;
    },
    close: function() {
      ws.close();
    }
  };
}
